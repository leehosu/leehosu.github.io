{"componentChunkName":"component---src-templates-post-template-jsx","path":"/kubernetes-apply-pod","result":{"data":{"markdownRemark":{"html":"<h1 id=\"들어가며\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\" aria-label=\"들어가며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가며</h1>\n<p>kubectl 명령을 통해 pod를 생성하거나 수정할 때에 무슨 과정이 일어나는지에 대해 포스팅 해보았습니다. kubernetes를 사용 및 관리한다면 알아야 할 정말 기초적인 일련의 과정이지만 막상 kubernetes cluster object들이 무슨 일을 하는지 모를 수 있으니 이번 기회에 개념을 확! 잡고 갑니다!</p>\n<h1 id=\"overview\" style=\"position:relative;\"><a href=\"#overview\" aria-label=\"overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overview</h1>\n<p><img src=\"/35076c02a10d22d1a65beae631f13452/overview_2.gif\" alt=\"overview\"></p>\n<h2 id=\"kubectl-apply-명령어가-적용되는-순서\" style=\"position:relative;\"><a href=\"#kubectl-apply-%EB%AA%85%EB%A0%B9%EC%96%B4%EA%B0%80-%EC%A0%81%EC%9A%A9%EB%90%98%EB%8A%94-%EC%88%9C%EC%84%9C\" aria-label=\"kubectl apply 명령어가 적용되는 순서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>kubectl apply 명령어가 적용되는 순서</h2>\n<ol>\n<li>client → kube-apiserver</li>\n<li>kube-apiserver → etcd</li>\n<li>kube-apiserver → kube-controller-manager</li>\n<li>kube-apiserver → kube-scheduler</li>\n<li>kube-apiserver → kubelet → Container Runtime</li>\n<li>kube-apiserver → etcd</li>\n</ol>\n<br>\n<br>\n<h1 id=\"1-client-→-kube-apiserver\" style=\"position:relative;\"><a href=\"#1-client-%E2%86%92-kube-apiserver\" aria-label=\"1 client → kube apiserver permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) client → kube-apiserver</h1>\n<p><code class=\"language-text\">kubectl</code> 클라이언트는 <code class=\"language-text\">deployment.yaml</code> 파일에 정의된 <code class=\"language-text\">resource</code>를 생성하거나 수정하기 위해 <code class=\"language-text\">kube-apiserver</code>에 요청을 보냅니다.</p>\n<h2 id=\"kube-apiserver\" style=\"position:relative;\"><a href=\"#kube-apiserver\" aria-label=\"kube apiserver permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>kube-apiserver</h2>\n<p><code class=\"language-text\">Kubernetes Cluster</code>의 모든 컴포넌트와 사용자가 상호 작용할 수 있도록 중앙 집중식 <code class=\"language-text\">API</code>를 제공하며, 특히 <code class=\"language-text\">Kuberentes Cluster</code>의 게이트키퍼(클러스터 내부 또는 외부의 모든 API 요청을 처리하고, 해당 요청이 유효하고 권한이 있는지 확인) 역할을 합니다.</p>\n<h3 id=\"주요-기능\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%9A%94-%EA%B8%B0%EB%8A%A5\" aria-label=\"주요 기능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>주요 기능</strong></h3>\n<ul>\n<li><strong>RESTful API 제공</strong> : <code class=\"language-text\">RESTful API</code>를 통해 클라이언트와 통신합니다. 이 <code class=\"language-text\">API</code>를 통해 <code class=\"language-text\">Resource</code>를 생성, 읽기, 수정, 삭제(<code class=\"language-text\">CRUD</code>)할 수 있습니다.</li>\n<li><strong>인증</strong>: <code class=\"language-text\">client</code>가 실행한 명령에 의해 <code class=\"language-text\">cluster</code>내에 접근하기 전에 토큰, 인증서, 기본 인증 등 다양한 방법으로 누구인지 확인합니다.</li>\n<li><strong>인가</strong> : 인증된 <code class=\"language-text\">client</code>가 특정 <code class=\"language-text\">resource</code>에 대한 작업을 수행할 권한이 있는지 <code class=\"language-text\">Role-Based Access Control (RBAC)</code>, <code class=\"language-text\">Attribute-Based Access Control (ABAC)</code> 등을 통해 수행됩니다.</li>\n<li><strong>데이터 유효성 검사</strong>: 들어오는 요청이 유효한 형식과 데이터를 가지고 있는지 검사합니다.</li>\n<li><strong>API 요청 라우팅</strong>: 들어오는 <code class=\"language-text\">API</code> 요청을 적절한 서비스나 컴포넌트로 라우팅합니다.</li>\n<li><strong>API Aggregation</strong>: 여러 <code class=\"language-text\">API</code> 버전과 추가적인 <code class=\"language-text\">API server</code>를 하나의 <code class=\"language-text\">API Endpoint</code>로 묶을 수 있습니다.</li>\n<li><strong>상태 저장</strong>: <code class=\"language-text\">kube-apiserver</code>는 일반적으로 <code class=\"language-text\">etcd</code>와 같은 분산 데이터 스토어에 클러스터 상태를 저장합니다.</li>\n</ul>\n<br>\n<br>\n<h1 id=\"2-kube-apiserver-→-etcd\" style=\"position:relative;\"><a href=\"#2-kube-apiserver-%E2%86%92-etcd\" aria-label=\"2 kube apiserver → etcd permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) kube-apiserver → ETCD</h1>\n<p>유효성 검사가 통과되면, <strong><code class=\"language-text\">kube-apiserver</code></strong>는 <strong><code class=\"language-text\">etcd</code></strong> 데이터베이스에 리소스의 상태를 저장합니다.</p>\n<h2 id=\"etcd\" style=\"position:relative;\"><a href=\"#etcd\" aria-label=\"etcd permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ETCD</h2>\n<p><code class=\"language-text\">etcd</code>는 분산 <code class=\"language-text\">key-value</code>저장소로, 데이터를 저장하고 고가용성을 제공하며 주로 분산 시스템의 설정 정보, 상태 정보, 메타데이터 등을 저장하는 데 사용됩니다. </p>\n<h3 id=\"주요-특징\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%9A%94-%ED%8A%B9%EC%A7%95\" aria-label=\"주요 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>주요 특징</strong></h3>\n<ul>\n<li><strong>고가용성</strong>: <code class=\"language-text\">etcd cluster</code>는 여러 <code class=\"language-text\">node</code>노드로 구성되며, 일부 <code class=\"language-text\">node</code>가 실패해도 계속 작동합니다.</li>\n<li><strong>일관성</strong>: <code class=\"language-text\">etcd</code>는 <code class=\"language-text\">Raft</code> 합의 알고리즘을 사용하여 분산 <code class=\"language-text\">node</code> 간에 데이터의 일관성을 유지합니다.</li>\n<li><strong>분산 시스템</strong>: <code class=\"language-text\">etcd</code>는 분산 시스템을 통해 네트워크 파티션, 장애 복구 등 복잡한 문제를 해결합니다.</li>\n<li><strong>트랜잭션 지원</strong>: 여러 연산을 하나의 트랜잭션으로 묶을 수 있습니다.</li>\n<li><strong>보안</strong>: <code class=\"language-text\">etcd</code>는 <code class=\"language-text\">TLS</code>를 통해 데이터를 암호화하고, 인증서를 통해 클라이언트와 서버 간의 신뢰성을 확보합니다.</li>\n<li><strong>key-value 모델</strong>: 간단한 <code class=\"language-text\">key-value</code> 데이터 모델을 사용하여 데이터를 저장하고 검색합니다.</li>\n</ul>\n<h3 id=\"kubernetes에서의-역할\" style=\"position:relative;\"><a href=\"#kubernetes%EC%97%90%EC%84%9C%EC%9D%98-%EC%97%AD%ED%95%A0\" aria-label=\"kubernetes에서의 역할 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Kubernetes에서의 역할</strong></h3>\n<p><code class=\"language-text\">etcd</code>는 <code class=\"language-text\">kubernetes cluster</code>의 모든 상태 정보를 저장합니다.</p>\n<p>즉, <strong><code class=\"language-text\">kube-apiserver</code></strong>는 <code class=\"language-text\">etcd</code>와 통신하여 이러한 정보를 읽고 쓰며, 다른 <code class=\"language-text\">Kubernetes</code> 컴포넌트들은 <strong><code class=\"language-text\">kube-apiserver</code></strong>를 통해 이 정보에 접근합니다. 이렇게 해서 <code class=\"language-text\">Kubernetes cluster</code>의 모든 컴포넌트가 일관된 상태 정보를 가질 수 있습니다.</p>\n<br>\n<br>\n<h1 id=\"3-kube-apiserver---kube-controller-manager\" style=\"position:relative;\"><a href=\"#3-kube-apiserver---kube-controller-manager\" aria-label=\"3 kube apiserver   kube controller manager permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3) kube-apiserver -> kube-controller-manager</h1>\n<p><strong><code class=\"language-text\">kube-apiserver</code></strong>는 리소스의 상태가 변경되었음을 <strong><code class=\"language-text\">kube-controller-manager</code></strong>에 알려주게 됩니다.</p>\n<h2 id=\"kube-controller-manager\" style=\"position:relative;\"><a href=\"#kube-controller-manager\" aria-label=\"kube controller manager permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>kube-controller-manager</h2>\n<p><strong><code class=\"language-text\">kube-controller-manager</code></strong>는 <code class=\"language-text\">Kubernetes cluster</code>에서 여러 개의 컨트롤러를 실행하는 컴포넌트입니다. 이 컴포넌트는 클러스터의 전반적인 상태를 관리하고, 필요한 작업을 자동으로 수행하며, <strong><code class=\"language-text\">kube-apiserver</code></strong>와 통신하여 <code class=\"language-text\">cluster</code>의 상태를 읽고 업데이트합니다.</p>\n<h3 id=\"주요-기능-1\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%9A%94-%EA%B8%B0%EB%8A%A5-1\" aria-label=\"주요 기능 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>주요 기능</strong></h3>\n<ul>\n<li><strong>상태 관리</strong> : 클러스터의 다양한 <code class=\"language-text\">resource</code> 상태를 지속적으로 체크하고, 필요한 경우 조정합니다.</li>\n<li><strong>자동화</strong> : <code class=\"language-text\">node</code>가 어떠한 이유로 <code class=\"language-text\">pod</code>를 유지할 수 없게된다면 자동으로 해당 <code class=\"language-text\">node</code>에서 실행되던 <code class=\"language-text\">pod</code>를 다른 <code class=\"language-text\">node</code>로 옮기는 등의 작업을 자동으로 수행합니다.</li>\n<li><strong>스케일링</strong> : <code class=\"language-text\">pod</code>의 수를 자동으로 늘리거나 줄일 수 있습니다.</li>\n<li><strong>롤아웃과 롤백</strong>: 새로운 버전의 애플리케이션을 안전하게 배포하고, 문제가 발생하면 이전 버전으로 롤백할 수 있습니다.</li>\n</ul>\n<h3 id=\"주요-컨트롤러\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%9A%94-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC\" aria-label=\"주요 컨트롤러 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>주요 컨트롤러</strong></h3>\n<ul>\n<li><strong>Node Controller</strong>: <code class=\"language-text\">node</code>의 상태를 모니터링하고, <code class=\"language-text\">node</code>가 다운되면 이를 감지하여 적잘한 조치를 취합니다.</li>\n<li><strong>Replication Controller</strong>: 지정된 수의 <code class=\"language-text\">Pod</code>의 <code class=\"language-text\">Replicas</code>가 항상 유지되고 있는지 확인합니다.</li>\n<li><strong>Deployment Controller</strong>: 사용자가 선언한 상태를 기반으로 <code class=\"language-text\">Pod</code>와 <code class=\"language-text\">ReplicaSets</code>을 관리합니다.</li>\n<li><strong>StatefulSet Controller</strong>: 상태를 유지하는 <code class=\"language-text\">Pod</code>의 배포와 스케일링을 관리합니다.</li>\n<li><strong>DaemonSet Controller</strong>: 모든 (또는 일부) <code class=\"language-text\">node</code>에서 <code class=\"language-text\">deamonsets</code>의 복제본이 실행되도록 관리합니다.</li>\n<li><strong>Job Controller</strong>: 배치 작업을 실행합니다.</li>\n<li><strong>Horizontal Pod Autoscaler</strong>: <code class=\"language-text\">CPU</code> 사용량 등의 <code class=\"language-text\">metric</code>을 기반으로 <code class=\"language-text\">pod</code>의 수를 자동으로 조절합니다.</li>\n<li><strong>Persistent Volume Controller</strong>: <code class=\"language-text\">storage</code> 요구사항에 따라 <code class=\"language-text\">persistent volume</code>을 생성하고 관리합니다.</li>\n</ul>\n<br>\n<br>\n<h1 id=\"4-kube-apiserver-→-kube-scheduler\" style=\"position:relative;\"><a href=\"#4-kube-apiserver-%E2%86%92-kube-scheduler\" aria-label=\"4 kube apiserver → kube scheduler permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4) kube-apiserver → kube-scheduler</h1>\n<p>새로 생성된 <code class=\"language-text\">pod</code>는 초기에는 <code class=\"language-text\">Pending</code> 상태입니다. 이 <code class=\"language-text\">pod</code>를 적절한 <code class=\"language-text\">node</code>에 배포하기 위해  <strong><code class=\"language-text\">kube-scheduler</code></strong> 가 동작합니다. (<code class=\"language-text\">kube-scheduler</code> 가 <code class=\"language-text\">pod</code>를 직접 배포를 하는 것이 아니라 <code class=\"language-text\">pod</code>가 배포될만한 적절한 <code class=\"language-text\">node</code>를 찾는 작업을 합니다.)</p>\n<h2 id=\"kube-scheduler\" style=\"position:relative;\"><a href=\"#kube-scheduler\" aria-label=\"kube scheduler permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>kube-scheduler</h2>\n<p><code class=\"language-text\">kube-scheduler</code>는 <code class=\"language-text\">Kubernetes Cluster</code>에서  여러 가지 <code class=\"language-text\">metric</code>과 규칙, 정책등을 고려하여 <code class=\"language-text\">Pod</code>의 <code class=\"language-text\">scheduling</code> (어떤 <code class=\"language-text\">Pod</code>를 어떤 <code class=\"language-text\">Node</code>에 배치할 것인지를 결정하는 과정) 을 담당하는 컴포넌트입니다. </p>\n<h3 id=\"작동-원리\" style=\"position:relative;\"><a href=\"#%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC\" aria-label=\"작동 원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>작동 원리</strong></h3>\n<ul>\n<li><strong>파악</strong>: <code class=\"language-text\">kube-apiserver</code>를 통해 새로 생성되거나 아직 할당되지 않은 <code class=\"language-text\">Pod</code>를 감지합니다.</li>\n<li><strong>선택</strong>: 감지된 <code class=\"language-text\">Pod</code>에 대해 여러 가지 <code class=\"language-text\">scheduling</code> 알고리즘과 정책을 적용하여 가장 적합한 <code class=\"language-text\">worker node</code>를 선택합니다.</li>\n<li><strong>할당</strong>: 선택된 <code class=\"language-text\">node</code>에 <code class=\"language-text\">pod</code>를 할당하고, 이 정보를 <code class=\"language-text\">kube-apiserver</code>에 정보를 전달합니다.</li>\n</ul>\n<h3 id=\"고려하는-요인\" style=\"position:relative;\"><a href=\"#%EA%B3%A0%EB%A0%A4%ED%95%98%EB%8A%94-%EC%9A%94%EC%9D%B8\" aria-label=\"고려하는 요인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>고려하는 요인</strong></h3>\n<ul>\n<li><strong>리소스 요구사항</strong>: <code class=\"language-text\">CPU</code>, <code class=\"language-text\">Memory</code>, <code class=\"language-text\">Storage</code> 등의 <code class=\"language-text\">resources</code>가 충분한지</li>\n<li><strong>노드 제약사항</strong>: <code class=\"language-text\">node-selector</code>, <code class=\"language-text\">node-affinity</code>, <code class=\"language-text\">Taints</code>, <code class=\"language-text\">Tolerations</code> 등이 설정되어있는지</li>\n<li><strong>데이터 지역성</strong>: 데이터를 가까운 곳에서 처리할 수 있도록 <code class=\"language-text\">node</code>를 선택</li>\n<li><strong>로드 밸런싱</strong>: 모든 <code class=\"language-text\">node</code>에서 균등하게 <code class=\"language-text\">resources</code>를 사용할 수 있도록 <code class=\"language-text\">node</code>를 선택</li>\n<li><strong>사용자 정의 정책</strong>: 사용자가 정의한 <code class=\"language-text\">scheduling</code> 정책 또는 알고리즘을 적용</li>\n</ul>\n<br>\n<br>\n<h1 id=\"5-kube-apiserver-→-kubelet\" style=\"position:relative;\"><a href=\"#5-kube-apiserver-%E2%86%92-kubelet\" aria-label=\"5 kube apiserver → kubelet permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5) kube-apiserver → kubelet</h1>\n<p><code class=\"language-text\">Woker Node</code>에서 <code class=\"language-text\">kubelet</code>과 함께 동작하는 <code class=\"language-text\">Container Runtime</code>이 <code class=\"language-text\">Pod</code>를 생성하고 실행합니다.</p>\n<h2 id=\"kubelet\" style=\"position:relative;\"><a href=\"#kubelet\" aria-label=\"kubelet permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Kubelet</h2>\n<p><code class=\"language-text\">kubelet</code>은 <code class=\"language-text\">Kubernetes Cluster</code>의 각 <code class=\"language-text\">Worker Node</code>에서 실행되는 <code class=\"language-text\">Agent</code>입니다. 이 <code class=\"language-text\">Agent</code>는 <code class=\"language-text\">Node</code>에서 <code class=\"language-text\">Container</code>의 실행, 중지, 업데이트 등을 관리하며, <code class=\"language-text\">Node</code>의 상태를 모니터링합니다. <code class=\"language-text\">kubelet</code>은 앞의 작업을 수행하고 <code class=\"language-text\">kube-apiserver</code>와 통신하여 상태 정보를 전달합니다.</p>\n<h3 id=\"주요-기능-2\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%9A%94-%EA%B8%B0%EB%8A%A5-2\" aria-label=\"주요 기능 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>주요 기능</strong></h3>\n<ul>\n<li><strong>파드 수명 주기 관리</strong> : <code class=\"language-text\">kube-apiserver</code>로부터 <code class=\"language-text\">Pod</code>의 명세(spec)를 받아와 해당 <code class=\"language-text\">Node</code>에서 <code class=\"language-text\">Pod</code>와 그 안의 <code class=\"language-text\">Container</code>를 실행합니다.</li>\n<li><strong>노드 상태 모니터링</strong>: <code class=\"language-text\">Node</code>의 <code class=\"language-text\">CPU</code>, <code class=\"language-text\">Memory</code>, 디스크 사용량 등을 <code class=\"language-text\">moniroting</code>하고 이 정보를 <code class=\"language-text\">kube-apiserver</code> 전달합니다.</li>\n<li><strong>리소스 격리</strong>: <code class=\"language-text\">kubelet</code>은 <code class=\"language-text\">cgroups</code>, <code class=\"language-text\">namespaces</code> 등의 리눅스 커널 기능을 활용하여 <code class=\"language-text\">Pod</code>와 <code class=\"language-text\">Container</code>의 <code class=\"language-text\">Resource</code>를 격리합니다.</li>\n<li><strong>로그 및 메트릭 수집</strong>: 설정에 따라 <code class=\"language-text\">Container</code>의 <code class=\"language-text\">Log</code>를 수집하고, <code class=\"language-text\">Metric</code>을 추출하여 필요한 경우 외부 시스템에 전달합니다.</li>\n<li><strong>자동 복구</strong>: 설정에 따라 <code class=\"language-text\">Container</code>나 <code class=\"language-text\">Pod</code>가 실패하면 자동으로 복구 작업을 수행합니다.</li>\n<li><strong>컨테이너 런타임 인터페이스(CRI) 지원</strong>: 다양한 <code class=\"language-text\">Container Runtime</code>(<code class=\"language-text\">Docker</code>, <code class=\"language-text\">containerd</code>, <code class=\"language-text\">CRI-O</code> 등)과 통신할 수 있습니다.</li>\n</ul>\n<h3 id=\"작동-방식\" style=\"position:relative;\"><a href=\"#%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D\" aria-label=\"작동 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>작동 방식</strong></h3>\n<ol>\n<li><strong>API 서버로부터 파드 정보 가져오기</strong>: <code class=\"language-text\">kubelet</code>은 <code class=\"language-text\">kube-apiserver</code>와 통신하여 해당 노드에 스케줄링된 파드의 목록과 상태 정보를 가져옵니다.</li>\n<li><strong>원하는 상태와 현재 상태 비교</strong>: <code class=\"language-text\">kubelet</code>은 가져온 파드의 원하는 상태(Desired State)와 노드의 현재 상태(Current State)를 비교합니다.</li>\n<li><strong>컨테이너 런타임에 명령 내리기</strong>: 원하는 상태와 현재 상태가 일치하지 않으면, <code class=\"language-text\">kubelet</code>은 <code class=\"language-text\">Container Rumtime</code> 에게 필요한 작업을 수행하도록 명령을 내립니다.</li>\n<li><strong>상태 업데이트</strong>: 작업이 완료되면, <code class=\"language-text\">kubelet</code>은 파드의 상태를 업데이트하고 이 정보를 다시 API 서버에 보고합니다.</li>\n<li><strong>로그 및 메트릭스 모니터링</strong>: <code class=\"language-text\">kubelet</code>은 또한 <code class=\"language-text\">Container</code>의 <code class=\"language-text\">Log</code>와 <code class=\"language-text\">Metric</code> 를 수집하여 필요한 경우 중앙 로깅 및 모니터링 시스템에 전달할 수 있습니다.</li>\n</ol>\n<h2 id=\"container-runtime\" style=\"position:relative;\"><a href=\"#container-runtime\" aria-label=\"container runtime permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Container Runtime</h2>\n<p><code class=\"language-text\">Container</code>를 실행, 중지, 관리하는 역할을 하는 소프트웨어 컴포넌트로써 <code class=\"language-text\">kubelet</code>과 통신하여 <code class=\"language-text\">Worker Node</code>에서 <code class=\"language-text\">Container</code>의 생명주기를 관리합니다.</p>\n<h3 id=\"주요-container-runtime\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%9A%94-container-runtime\" aria-label=\"주요 container runtime permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>주요 Container Runtime</strong></h3>\n<p><strong>Docker</strong> : 가장 널리 사용되는 <code class=\"language-text\">Container Runtime</code> 중 하나이며 사용하기 쉬운 <code class=\"language-text\">CLI</code>와 <code class=\"language-text\">API</code>를 제공하고 다양한 플랫폼에서 지원됩니다.</p>\n<p><strong>containerd</strong> : <code class=\"language-text\">Docker</code>의 일부로 시작되었으나 현재는 독립적인 프로젝트이며, <code class=\"language-text\">OCI(Open Container Initiative)</code> 표준을 따르고 <code class=\"language-text\">Docker</code> 엔진 위에서도 작동합니다.</p>\n<p><strong>CRI-O</strong> : <code class=\"language-text\">CRI(Container Runtime Interface)</code>가 구현된 <code class=\"language-text\">Kubernetes</code>를 위한 경량의 <code class=\"language-text\">Container Runtime</code>입니다. </p>\n<h3 id=\"역할\" style=\"position:relative;\"><a href=\"#%EC%97%AD%ED%95%A0\" aria-label=\"역할 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>역할</strong></h3>\n<ul>\n<li><strong>이미지 관리</strong>: <code class=\"language-text\">Container</code> 이미지를 다운로드하고 저장합니다.</li>\n<li><strong>컨테이너 실행</strong>: <code class=\"language-text\">Container</code> 를 시작, 중지, 재시작 등의 작업을 수행합니다.</li>\n<li><strong>로깅과 모니터링</strong>: <code class=\"language-text\">Container</code>의 <code class=\"language-text\">Log</code>를 수집하고, <code class=\"language-text\">resources</code> 사용량을 모니터링합니다.</li>\n<li><strong>보안</strong>: 하나의 <code class=\"language-text\">Container</code>가 다른 <code class=\"language-text\">Container</code>나 호스트 시스템에 영향을 주지 않도록 격리합니다.</li>\n<li><strong>네트워킹</strong>: <code class=\"language-text\">Container</code> 간의 통신과 외부와의 통신을 관리합니다.</li>\n</ul>\n<br>\n<br>\n<h1 id=\"6-kube-apiserver-→-etcd\" style=\"position:relative;\"><a href=\"#6-kube-apiserver-%E2%86%92-etcd\" aria-label=\"6 kube apiserver → etcd permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6) kube-apiserver → ETCD</h1>\n<p><code class=\"language-text\">Pod</code>의 상태가 변경되면 이 정보는 다시 <code class=\"language-text\">kube-apiserver</code>를 통해 <code class=\"language-text\">etcd</code>에 업데이트됩니다.</p>","timeToRead":9,"excerpt":"들어가며 kubectl 명령을 통해 pod를 생성하거나 수정할 때에 무슨 과정이 일어나는지에 대해 포스팅 해보았습니다. kubernetes를 사용 및 관리한다면 알아야 할 정말 기초적인 일련의 과정이지만 막상 kubernetes cluster…","frontmatter":{"title":"KUBERNETES에서 POD가 생성되고 업데이트 되는 과정","date":"2023-09-12 23:00","categories":["Devops","Kubernetes"],"tags":["Devops","Kubernetes"],"description":null,"keywords":"devops","cover":null},"fields":{"slug":"/kubernetes-apply-pod","date":"2023-09-12T14:00:00.000Z"}}},"pageContext":{"slug":"/kubernetes-apply-pod","nexttitle":"kube-prometheus-stack으로 모니터링 시스템 구축하기","nextslug":"/kube-prometheus-stack","prevtitle":" 2020년 회고","prevslug":"/review2020","tagList":["Devops","Kubernetes","promehtues","loki","grafana","Observability","AWS","AWS EKS","AWS EC2","AWS OpenSearch","EFKStack","EC2","ArgoCD","Slack","metric","K8s","Storage","EKS","Linux","Ubuntu","Gitlab","Jenkins","config","terminal","iterms","git","github","develop","Java","Spring","cron","React.js","Redux.js","Javascript","DB","DataBase","MySQL","vue","spring","mysql","jsp","db"],"categoryList":["Devops","Kubernetes","promehtues","loki","grafana","Observability","AWS","AWS EKS","AWS EC2","EFKStack","EC2","ArgoCD","Slack","metric","Storage","Linux","Ubuntu","config","git","Java","React.js","DataBase","develop"],"latestPostEdges":[{"node":{"fields":{"slug":"/kubernetes-apply-pod"},"frontmatter":{"template":"post","title":"KUBERNETES에서 POD가 생성되고 업데이트 되는 과정","tags":["Devops","Kubernetes"],"categories":["Devops","Kubernetes"],"date":"2023-09-12 23:00"}}},{"node":{"fields":{"slug":"/kube-prometheus-stack"},"frontmatter":{"template":"post","title":"kube-prometheus-stack으로 모니터링 시스템 구축하기","tags":["Devops","Kubernetes","promehtues","loki","grafana","Observability"],"categories":["Devops","Kubernetes","promehtues","loki","grafana","Observability"],"date":"2023-08-27 15:40"}}},{"node":{"fields":{"slug":"/aws-eks-ng"},"frontmatter":{"template":"post","title":"좌충우돌 AWS EKS Nodegroup 전환기","tags":["Devops","Kubernetes","AWS","AWS EKS","AWS EC2"],"categories":["Devops","Kubernetes","AWS","AWS EKS","AWS EC2"],"date":"2023-08-15 13:00"}}},{"node":{"fields":{"slug":"/kubernetes-service"},"frontmatter":{"template":"post","title":"쿠버네티스 service란?!","tags":["Devops","Kubernetes"],"categories":["Devops","Kubernetes"],"date":"2023-08-03 11:40"}}}]}},"staticQueryHashes":[]}